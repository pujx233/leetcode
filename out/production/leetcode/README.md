[TOC]

### 每日一题

#### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

- [x] 递归
- [x] 迭代

#### [83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

- [x] 递归

#### [82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)

- [x] 递归
- [x] 迭代

#### [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

- [x] 双指针
- [x] 遍历（不推荐）
- [x] 栈

#### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

- [x] 哈希表
- [x] 暴力枚举

#### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

- [x] 滑动窗口

#### [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

- [x] 迭代

#### [237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)

- [x] 当前节点绕过下一个节点，并将当前节点完全改造成下一个节点

#### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

- [x] 递归
- [x] 迭代

#### [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

- [ ] 回溯法

#### [95. 不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)

- [x] 只要求返回数量，使用动态规划

#### [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

- [x] 递归
- [x] 中序遍历
  - [x] 递归
  - [x] 迭代

#### [509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

- [x] 动态规划

#### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

- [x] 动态规划

#### [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)  

- [ ] 深度搜索、广度搜索

#### [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)

- [ ] LinkedHashMap(并不会写，要时常回顾)

#### [99. 恢复二叉搜索树](https://leetcode-cn.com/problems/recover-binary-search-tree/)

- [x] 中序遍历
  - [x] 迭代
  - [x] 递归
- [ ] 难度为Hard是因为该题鼓励使用Morris算法进行二叉树遍历，暂时不考虑

#### [222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

- [x] DFS (常规解法递归)
- [x] BFS (超时)
- [x] 利用完全二叉树的特性

#### [71. 简化路径](https://leetcode-cn.com/problems/simplify-path/)

- [x] 栈

#### [15. 三数之和](https://leetcode-cn.com/problems/3sum/)

- [x] 双指针

#### [18. 四数之和](https://leetcode-cn.com/problems/4sum/)

- [x] 双指针

#### [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

- [x] 哈希表
- [x] 快慢指针

#### [36. 有效的数独](https://leetcode-cn.com/problems/valid-sudoku/)

- [x] 哈希表

#### [912. 排序数组](https://leetcode-cn.com/problems/sort-an-array/)

- [ ] 快速排序
- [ ] 哈希排序
- [ ] 堆并排序

……

#### [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

- [x] 排序

#### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

- [x] 回溯算法

#### [415. 字符串相加](https://leetcode-cn.com/problems/add-strings/)

- [x] 列竖式

#### [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

- [x] 动态规划

#### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

- [x] 动态规划

#### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

- [x] 动态规划

#### [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii)

- [x] 动态规划

#### [188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)

- [x] 动态规划

#### [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

- [x] 动态规划

#### [714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

- [x] 股票问题均考虑用动态规划

#### [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

- [x] 迭代法
- [x] 递归法

#### [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

- [x] 双指针、头插法
- [x] 递归法

#### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

- [x] 动态规划

#### [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

- [x] 链表的后序遍历
- [x] 快慢指针

- [x] 或者将链表复制到数组以后双指针

#### [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

- [x] 头插法

#### [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

- [x] 哈希
- [x] 快慢指针

#### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

- [x] BFS

#### [1162. 地图分析](https://leetcode-cn.com/problems/as-far-from-land-as-possible/)

- [x] 多源BFS
- [x] 动态规划

#### [103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

- [x] BFS
- [x] 双端队列

#### [107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

- [x] BFS
- [x] List.add(0,node)

#### [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

- [x] 双指针

#### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

- [x] 栈

#### [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

- [x] DFS

#### [704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

- [x] 二分查找

#### [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

- [x] 二分查找

#### [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

- [x] 递归

#### [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

- [x] 哈希表
- [x] 快慢指针

#### [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)

- [x] 矩阵

#### [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

- [x] BFS
- [x] DFS

#### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

- [x] 动态规划
- [ ] 中心扩展算法

#### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

- [x] 动态规划


#### [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

- [x] 动态规划

#### [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

- [x] 双栈

#### [69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/)

- [x] 牛顿法
- [x] 二分查找

#### [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

- [x] 动态规划

#### [213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

- [x] 动态规划

#### [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

- [x] DFS

#### [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

- [x] 动态规划
- [ ] 二分查找

#### [470. 用 Rand7() 实现 Rand10()](https://leetcode-cn.com/problems/implement-rand10-using-rand7/)

- [x] 数学
- [x] (randX() - 1)*Y + randY() 可以等概率的生成[1, X * Y]范围的随机数

#### [225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

- [x] 单队列
- [x] 双队列

#### [143. 重排链表](https://leetcode-cn.com/problems/reorder-list/)

- [x] 线性表list可以简单获取链表

- [x] 寻找链表中点 + 链表逆序 + 合并链表
	* 求中间链表可用快慢链表

#### [876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)

- [x] 快慢链表
- [x] 注意中间前一个节点和中间后一个节点的写法不一样

#### [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

- [x] DFS,BFS进行层序遍历

#### [8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)

- [x] 字符串处理
- [ ] 自动机

#### [279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

- [x] 动态规划（硬币找零问题）

- [x]  本身是完全背包问题

#### [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)


- [x] 递归
- [x] 迭代

#### [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

- [x] 递归
- [ ] 迭代
  - [x] 迭代中有一种方法：基于前序遍历 根 -> 左 -> 右的顺序，易得 根 -> 右 -> 左 的顺序，逆序即可得到 左->右->根的顺序，即为后序遍历的方法。但是这种不符合对题目的理解，在面试中不合适
  - [x] 要对节点是否访问过进行记录，可以使用prev进行判断

#### [56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

- [x] 排序后进行合并
- [x] List 转数组 ans.toArray(new int[m] [n])
- [x] List 的赋值方式  ans.get(m) = a 
- [x] 数组的复制 Arrays.copyOf(res, idx + 1)
- [x] 数组创建默认值为0
- [x] lambda表达式/函数式编程  Arrays.sort(intervals, (v1,v2)->v1[0]-v2[0])


#### [151. 翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)

- [x] 调用API
  - [x] Arrays.asList 转list
  - [x] 多个空白字符匹配 s.split("\\s+")
  - [x] 字符串连接 String.join(" ",list)  
- [x] 考虑先进后出的特性，使用栈(Deque)
  - [x] StringBuild 清空：setLength(0)

#### [31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)

- [x] 全排列的相关理解：如何让混乱度增加的同时，数组的变化尽可能小

#### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

- [x] 深度优先搜索
- [x] 广度优先搜索

#### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

- [x] 递归
- [ ] 迭代（暂时不想看了）

#### [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

- [x] 深度优先搜索
- [x] 动态规划

#### [637. 二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)

- [x] 深度优先搜索 ：要求维护层数和总数
- [x] 广度优先搜索

#### [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

- [x] 先序遍历

  - [x] 迭代

  - [x] 递归：注意相连时用快慢指针
- [x]     暴力解：右子树移到左子树最右最下，整个左子树再移到右子树的位置上
- [ ]     要求不需要额外空间，考虑使用morris

#### [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

- [x] 自顶向下的递归
- [x] 自底向上的递归
  - [x] 自底向上递归的做法类似于后序遍历，对于当前遍历到的节点，先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是非负整数），否则返回 -1−1。如果存在一棵子树不平衡，则整个二叉树一定不平衡。

* 本质上是前序遍历和后序遍历的区别

#### [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

- [x] 和124.二叉树的最大路径和思路类似，使用深度优先搜索
- [x] 注意要确定返回条件，所以计算的时候要算节点数量而不是关系数量，最后再-1

#### [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

- [x] 广度优先搜索
- [x] 递归（深度优先搜索）：自下而上递归

#### [129. 求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)

- [x] 广度优先搜索：注意为叶节点时的判断边界
- [x] 深度优先搜索：注意要传值

#### [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

- [x] 深度优先搜索：二分查找 （注意边界条件是left>right,没有=）

#### [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)

- [ ] 归并排序
  - [ ] 迭代
  - [ ] 递归
- [ ] 快速排序（链表的拼接很少见）

#### [147. 对链表进行插入排序](https://leetcode-cn.com/problems/insertion-sort-list/)

- [x] 插入排序

  - [x] 从前往后找插入点
  - [x] pre 作为指针，在重新插入的时候发挥作用

#### [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

- [x] 动态规划

#### [718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)

- [x] 动态规划
  - [x] 动态规划省时间 滑动窗口省空间
- [x] 滑动窗口
  - [x] 想象两把尺子，错开之后比较相同的部分，找最长相同的串就好了。

#### [75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)

- [x] 求每种颜色数量再返回
- [x] 类似练习里OnSortArray的思路，单指针进行交换
- [x] 双指针一步到位

#### [26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

- [x] 快慢指针

#### [459. 重复的子字符串](https://leetcode-cn.com/problems/repeated-substring-pattern/)

- [x] KMP 算法

####  [28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)

- [x] KMP 算法

#### [1392. 最长快乐前缀](https://leetcode-cn.com/problems/longest-happy-prefix/)

- [x] KMP算法

#### [补充：求岛屿头尾最短路径](https://blog.csdn.net/weixin_45907832/article/details/107214186)

- [x] Floyd算法
- [ ] Dijkstra算法
- [x] 深度优先搜索
- [x] 广度优先搜索（BFS对于求最短优于DFS）
  - [x] 广度优先和Dijkstra都要注意标注已访问

#### [补充：运算表达式转换为二叉树](https://www.cnblogs.com/ysocean/p/7910432.html)

- [x] 运算为中缀（中序遍历），转化为二叉树要知道前缀（前序遍历）
  - [x] 中缀表达式转前缀表达式
  - [x] 参考105：从前序与中序遍历序列构造二叉树

#### [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

- [x] 递归
  - [x] 强调了根节点到叶子节点，判断起来会方便一些
- [x] 广度优先遍历

#### [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

- [x] 广度优先搜索
  - [x] 记录父子节点情况
- [x] 深度优先搜索
  - [x] 注意 List 内部添加list的时候，要使用类似这样的表达`ans.add(new LinkedList<>(path));`

#### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

- [x] 二分查找
  - [x] 如何弄清边界问题
  - [x] 当左边界要更新为`l = mid,r = mid-1`时，我们就令 `mid =(l + r + 1)/2`
  - [x] 当右边界要更新为`r = mid,l = mid+1`时，我们就令 `mid =(l + r)/2`

#### [875. 爱吃香蕉的珂珂](https://leetcode-cn.com/problems/koko-eating-bananas/)

- [x] 如何弄清边界问题

#### [剑指 Offer 45. 把数组排成最小的数](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)

- [x] `l+r >r+l`,通过字符串相加的方式可以比较两个字符串的大小
  - [ ] lambda排序 `Arrays.sort(str,(x,y)->(x+y).compareTo(y+x));`
  - [ ] 快排 字符串自身也可以compareTo

#### [179. 最大数](https://leetcode-cn.com/problems/largest-number/)

- [x] lambda排序 `Arrays.sort(str,(x,y)->(x+y).compareTo(y+x));`
- [x] 快排 字符串自身也可以compareTo

#### [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

- [x] 贪心算法

#### [45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)

- [ ] 贪心算法
  - [ ] 正向查找O(n)
  - [ ] 反向查找O(n^2)

#### [面试题 17.22. 单词转换](https://leetcode-cn.com/problems/word-transformer-lcci/)

- [x] 广度优先搜索
  - [x] 和迷宫问题一样，为了防止死循环，要有一个判断是否访问的标志
  - [x] HashMap存储前驱

#### [253. Meeting Rooms II 会议室之二](https://www.cnblogs.com/grandyang/p/5244720.html)

- [ ] 优先队列实现最小堆

#### [78. 子集](https://leetcode-cn.com/problems/subsets/)

- [x] 回溯算法

- [x] 迭代法实现子集枚举

  - [x] 
    子集类型题目可以使用位运算
    

#### [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

- [x] 回溯算法


#### [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

- [x] 回溯算法
  - [x] 注意可以用HashSet去重，不过会超时
  - [x] 简便的方法是由于重复的会在回溯的第一阶段就计算，因此指针指向第二个及以后的时候进行顺延

#### [面试题 01.06. 字符串压缩](https://leetcode-cn.com/problems/compress-string-lcci/)

- [x] 标记字母和次数进行相加
  - [x] 注意字符串不能直接反转，可以转换成StringBuffer再反转

#### [443. 压缩字符串](https://leetcode-cn.com/problems/string-compression/)

- [x] 快慢指针
  - [x] 写的慢指针要从头开始，这样才能避免出现偏差
  - [x] 邻接条件很多很烦

#### [43. 字符串相乘](https://leetcode-cn.com/problems/multiply-strings/)

- [x] 用列竖式很麻烦，很容易错
  - [x] `num1[i]` 和 `num2[j]` 的乘积对应的就是`res[i+j]` 和 `res[i+j+1]` 这两个位置。

#### [560. 和为 K 的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

- [x] 前缀和处理区间问题
  - [x] 使用HashMap优化

#### [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

- [x] 动态规划
- [ ] 考察空间复杂度的优化
  - [ ] 优化一：由于`dp[i][j] = dp[i-1][j] + dp[i][j-1]`，因此只需要保留当前行与上一行的数据 (在动态方程中，即`pre[j] = dp[i-1][j]`)，两行，空间复杂度O(2n)；
  - [ ] 优化二：`cur[j] += cur[j-1]`, 即`cur[j] = cur[j] + cur[j-1]` 等价于思路二`cur[j] = pre[j] + cur[j-1]`，因此空间复杂度为O(n)

#### [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

- [x] 动态规划

#### [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

- [ ] 双指针

#### [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

- [x] 位运算（异或满足交换律和结合律）

#### [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)

- [x] 排序求中值
- [x] 哈希表
- [x] 投票算法（核心是对拼消耗）

#### [14. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)

- [x] 横向扫描
- [x] 纵向扫描

#### [剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

- [x] 倒序遍历

#### [162. 寻找峰值](https://leetcode-cn.com/problems/find-peak-element/)

- [x] 寻找最大值
- [x] 线性搜索
- [x] 二分搜索
  - [ ] 要注意题目条件，在题目描述中出现了 `nums[-1] = nums[n] = -∞`，这就代表着 **只要数组中存在一个元素比相邻元素大，那么沿着它一定可以找到一个峰值**

#### [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

- [x] 动态规划
- [x] 单调栈
- [x] 双指针

#### [7. 整数反转](https://leetcode-cn.com/problems/reverse-integer/)

- [x] 注意不超出范围的判断
- [ ] 正数和负数怎样算

#### [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

- [x] 顺序合并
- [ ] 归并合并
- [ ] 优先队列（注意链表的空间变化）

#### [204. 计数质数](https://leetcode-cn.com/problems/count-primes/)

- [x] 埃式筛

#### [1160. 拼写单词](https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/)

- [x] 哈希表
- [ ] hashmap.getOrDefault

#### [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

- [x] 回溯算法+深度优先遍历
  - [ ] 回溯算法要注意先剪枝
  - [x] 泛型括号内设定空间大小可降低占用空间

#### [48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/)

- [x] 水平翻转+对角线翻转

#### [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

- [x] 回溯算法+深度优先遍历
- [x] 判断具体的返回条件

#### [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

- [x] 二分查找
  - [ ] 比较前只考虑最右的特殊情况，是因为我们只需要在二分中找到大于等于target值的最小值

#### [852. 山脉数组的峰顶索引](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/)

- [x] 二分查找

#### [153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

- [x] 二分查找
  - [ ] 比较的对象要注意

#### [165. 比较版本号](https://leetcode-cn.com/problems/compare-version-numbers/)

- [x] 模拟

#### [128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)

- [x] 哈希表查找的时间复杂度为O(1)，因此考虑使用哈希表查找连续的数字。

#### [221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)

- [x] 动态规划

  ```java
  dp[row + 1][col + 1] = Math.min(Math.min(dp[row + 1][col], dp[row][col + 1]), dp[row][col]) + 1;
  ```

#### [468. 验证IP地址](https://leetcode-cn.com/problems/validate-ip-address/)

- [x] 分治法

  - [x] split("",-1)处理多个重复

```java
IP.chars().filter(ch -> ch == '.').count() == 3  //计算字符串中字符的数量
```

```java
Character.isDigit(ch)
```

#### [227. 基本计算器 II](https://leetcode-cn.com/problems/basic-calculator-ii/)

- [x] 栈处理符号* 、/

#### [224. 基本计算器](https://leetcode-cn.com/problems/basic-calculator/)

- [ ] 栈处理+、-